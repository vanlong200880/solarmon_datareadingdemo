var PARENT_DIRNAME, PARSER_SCHEMA, YAML_EXT, basename, co, dirname, dump, extname, fulfill, isAbsolute, isNumber, isString, join, junk, load, normalizeOptions, normalizePath, normalizePathSync, parse, read, readFile, readFileSync, readSync, readYamlFile, readdir, readdirSync, ref, ref1, ref2, ref3, resolve, write, writeFile, writeFileSync, writeSync, writeYamlFile, yaml,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

ref = require("path"), dirname = ref.dirname, basename = ref.basename, extname = ref.extname, isAbsolute = ref.isAbsolute, join = ref.join, resolve = ref.resolve;

ref1 = require("fs"), readFileSync = ref1.readFileSync, writeFileSync = ref1.writeFileSync, readdirSync = ref1.readdirSync;

co = require("co");

junk = require("junk");

ref2 = yaml = require("js-yaml"), parse = ref2.parse, load = ref2.load, dump = ref2.dump;

ref3 = require("promise-fs"), readFile = ref3.readFile, writeFile = ref3.writeFile, readdir = ref3.readdir;

PARSER_SCHEMA = {
  defaultSafe: yaml.DEFAULT_SAFE_SCHEMA,
  defaultFull: yaml.DEFAULT_FULL_SCHEMA,
  failsafe: yaml.FAILSAFE_SCHEMA,
  json: yaml.JSON_SCHEMA,
  core: yaml.CORE_SCHEMA
};

YAML_EXT = [".yaml", ".yml"];

isString = function(val) {
  return typeof val === "string";
};

isNumber = function(val) {
  return typeof val === "nubmber";
};

if ((module.parent != null) && isString(module.parent.filename)) {
  PARENT_DIRNAME = dirname(module.parent.filename);
  delete require.cache[__filename];
} else {
  PARENT_DIRNAME = process.cwd();
}


/*
 * Fulfill a promised function as callback-style function if it given
 *   or return a promise
 *
 * @param {function} cb
 * @param {fn} – promised function, wrapped into clojure (see yaml.read method)
 *
 * @return {void | Promise<any>}
*
* @api private
 */

fulfill = function(cb, fn) {
  var onFulfilled, onRejected, promise;
  if (typeof cb !== "function") {
    return fn();
  }
  onFulfilled = function(res) {
    return cb(null, res);
  };
  onRejected = function(err) {
    return cb(err);
  };
  promise = fn();
  promise.then(onFulfilled, onRejected);
};


/*
 * Normalize path to YAML file
 * 
 * @param {string} filename – Path to YAML file
 *
 * @return {Promise<string>}
 *
 * @api private
 */

normalizePath = function*(filename) {
  var __base, __ext, base, dir, file, files, i, len;
  if (!isAbsolute(filename)) {
    filename = resolve(PARENT_DIRNAME, filename);
  }
  base = basename(filename);
  dir = dirname(filename);
  files = (yield readdir(dir));
  for (i = 0, len = files.length; i < len; i++) {
    file = files[i];
    if (!(junk.not(file))) {
      continue;
    }
    __ext = extname(file);
    __base = basename(file, __ext);
    if (base === __base && indexOf.call(YAML_EXT, __ext) >= 0) {
      return join(dir, file);
    }
  }
  return filename;
};


/*
 * Normalize path to YAML file (Synchronously)
 * 
 * @param {string} filename - path to YAML file
 *
 * @return {string}
 *
 * @api private
 */

normalizePathSync = function(filename) {
  var __base, __ext, base, dir, file, files, i, len;
  if (!isAbsolute(filename)) {
    filename = resolve(PARENT_DIRNAME, filename);
  }
  base = basename(filename);
  dir = dirname(filename);
  files = readdirSync(dir);
  for (i = 0, len = files.length; i < len; i++) {
    file = files[i];
    if (!(junk.not(file))) {
      continue;
    }
    __ext = extname(file);
    __base = basename(file, __ext);
    if (base === __base && indexOf.call(YAML_EXT, __ext) >= 0) {
      return join(dir, file);
    }
  }
  return filename;
};


/*
 * Normalize options
 * 
 * @param {string | object} [options = {null}]
 * 
 * @return {object}
 *
 * @api private
 */

normalizeOptions = function(options) {
  if (options == null) {
    options = {};
  }
  if (options == null) {
    return {
      encoding: "utf8",
      schema: PARSER_SCHEMA.defaultSafe
    };
  }
  options = (function() {
    switch (typeof options) {
      case "string":
        return {
          encoding: options,
          schema: PARSER_SCHEMA.defaultSafe
        };
      case "object":
        options.encoding || (options.encoding = "utf8");
        options.schema || (options.schema = PARSER_SCHEMA.defaultSafe);
        return options;
    }
  })();
  return options;
};


/*
 * Read YAML file with Promise
 *
 * @param {number | string} filename - path or file descriptor
 * @param {object} [options = null]
 *
 * @return {Promise<object>}
 *
 * @api private
 */

readYamlFile = co.wrap(function*(filename, options) {
  var content;
  if (options == null) {
    options = {};
  }
  if (!isNumber(filename)) {
    filename = (yield normalizePath(filename));
  }
  options = normalizeOptions(options);
  content = (yield readFile(filename, options.encoding));
  return load(content, options);
});


/*
 * Read and parse YAML file
 * Note: Returns an instance of Promise unless callback given
 * 
 * @param {number | string} filename - path or file descriptor
 * @param {object} [options = null]
 * @param {function} [cb = null]
 * 
 * @return {void | Promise<object>}
 */

read = function(filename, options, cb) {
  var ref4;
  if (options == null) {
    options = {};
  }
  if (cb == null) {
    cb = null;
  }
  if (typeof options === "function") {
    ref4 = [options, {}], cb = ref4[0], options = ref4[1];
  }
  return fulfill(cb, function() {
    return readYamlFile(filename, options);
  });
};


/*
 * Synchronous version of yaml.read
 *
 * @param {string | number} filename – path or file descriptor
 * @param {string | object} [options = {}]
 * 
 * @return {object}
 */

readSync = function(filename, options) {
  var content;
  if (options == null) {
    options = {};
  }
  options = normalizeOptions(options);
  if (!isNumber(filename)) {
    filename = normalizePathSync(filename);
  }
  content = readFileSync(filename, options.encoding);
  content = load(content, options);
  return content;
};


/*
 * Write some content to YAML file with Promise
 * 
 * @param {string | number} – path or file descriptor
 * @paeam {any} content – a file contents
 * @param {string | object} [options = {}]
 * 
 * @return {void | Promise<void>}
 * 
 * @api private
 */

writeYamlFile = co.wrap(function*(filename, content, options) {
  if (options == null) {
    options = {};
  }
  if (!isNumber(filename)) {
    filename = (yield normalizePath(filename));
  }
  options = normalizeOptions(options);
  content = dump(content, options);
  yield writeFile(filename, content, options);
});


/*
 * Write some content to YAML file
 * Note: Returns an instance of Promise unless callback given
 * 
 * @param int|string filename - path or file descriptor
 * @param object content - File content
 * @param object options
 * @param function cb
 * 
 * @return {void | Promise<void>}
 */

write = function(filename, content, options, cb) {
  var ref4;
  if (options == null) {
    options = {};
  }
  if (cb == null) {
    cb = null;
  }
  if (typeof options === "function") {
    ref4 = [options, {}], cb = ref4[0], options = ref4[1];
  }
  return fulfill(cb, function() {
    return writeYamlFile(filename, content, options);
  });
};


/*
 * Synchronous version of yaml.write
 * 
 * @param {string | number} filename – path or file descriptor
 * @param {any} content – a file contents
 * 
 * @return {void}
 */

writeSync = function(filename, content, options) {
  if (options == null) {
    options = {};
  }
  filename = normalizePathSync(filename);
  options = normalizeOptions(options);
  content = dump(content);
  writeFileSync(filename, content, options.encoding || null);
};

module.exports = {
  parser: yaml,
  Type: yaml.Type,
  createSchema: yaml.Schema.create,
  schema: PARSER_SCHEMA,
  parse: load,
  dump: dump,
  read: read,
  readSync: readSync,
  write: write,
  writeSync: writeSync
};

//# sourceMappingURL=main.js.map
