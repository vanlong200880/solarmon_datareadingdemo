define("Utils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Mapping object to map a number to string
     */
    const NumberMap = {
        '0': 'không',
        '1': 'một',
        '2': 'hai',
        '3': 'ba',
        '4': 'bốn',
        '5': 'năm',
        '6': 'sáu',
        '7': 'bảy',
        '8': 'tám',
        '9': 'chín'
    };
    /**
     * This is error exception type of {@link NumberReader }
     */
    class NotNumberError extends Error {
        constructor(wrongNumber) {
            super(`Invalid number: ${wrongNumber}`);
            Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
        }
    }
    exports.NotNumberError = NotNumberError;
    /**
     * Get number from {@link NumberMap} according to the input single number
     * @param number the input number, only 1 char is valid
     * @return string the number in string
     */
    function getNumberFromMap(number) {
        if (Object.prototype.hasOwnProperty.call(NumberMap, number)) {
            return NumberMap[number];
        }
        else {
            throw new NotNumberError(number);
        }
    }
    exports.getNumberFromMap = getNumberFromMap;
});
define("Numbers", ["require", "exports", "Utils"], function (require, exports, Utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A group of three numbers, a component in the input number to read
     */
    class Numbers {
        constructor(s) {
            this.first = '';
            this.second = '';
            this.last = '';
            if (s.length > 0) {
                this.last = s[s.length - 1];
            }
            if (s.length > 1) {
                this.second = s[s.length - 2];
            }
            if (s.length > 2) {
                this.first = s[s.length - 3];
            }
        }
        /**
         * If the current {@link Numbers} is the first and before a {@link Billion} number, "nghìn" will be suffixed.
         * @param s the current string of the {@link Numbers}
         * @param firstNumber indicate that this is the first {@link Numbers}
         * @param beforeBillion indicate that this {@link Numbers} is before a {@link Billion} number
         * @return the string after suffixing "nghìn"
         */
        static suffixFirstAndBeforeBillion(s, firstNumber, beforeBillion) {
            if (firstNumber && beforeBillion) {
                s += ' nghìn';
            }
            return s;
        }
        /**
         * Read three digits of {@link Numbers}
         * @param firstNumber indicate that this is the first {@link Numbers} or not
         * @param beforeBillion indicate that this group number stands before a {@link Billion} group or not
         * @return the number in string in Vietnamese way
         */
        read(firstNumber, beforeBillion) {
            let s = '';
            if (this.isThreeZero()) {
                if (firstNumber) {
                    return 'không';
                }
                return '';
            }
            s = this.readFirstNumber(s);
            if (!this.isLastTwoZero()) {
                s = this.readSecondNumber(s);
                s = this.readLastNumber(s);
            }
            s = Numbers.suffixFirstAndBeforeBillion(s, firstNumber, beforeBillion);
            return s.trim();
        }
        /**
         * Indicate that whether the last two digits ({@link second) and {@link last}} of the {@link Numbers} are zero or not
         */
        isLastTwoZero() {
            return this.second === '0' && this.last === '0';
        }
        /**
         * Indicate that whether all three digits of the {@link Numbers} are zero or not
         */
        isThreeZero() {
            return this.first === '0' && this.second === '0' && this.last === '0';
        }
        /**
         * Read the first number of three digits of the {@link Numbers}
         * @param s the input number in string after read second number
         * @return the result after adding last number
         */
        readLastNumber(s) {
            if (this.second) {
                s = this.readLastAfterSecond(s);
            }
            else {
                s += ` ${Utils_1.getNumberFromMap(this.last)}`;
            }
            return s;
        }
        /**
         * Read the last number when second number is existed
         * @param s the number to read
         * @return the last number in string
         */
        readLastAfterSecond(s) {
            if (this.last === '1' && this.second !== '0' && this.second !== '1') {
                s += ' mốt';
            }
            else if (this.last === '5') {
                s += ' lăm';
            }
            else if (this.last !== '0') {
                s += ` ${Utils_1.getNumberFromMap(this.last)}`;
            }
            return s;
        }
        /**
         * Read the second number of three digits of the {@link Numbers}
         * @param s the input number in string after read first number
         * @return the result after adding second number
         */
        readSecondNumber(s) {
            if (this.second === '0') {
                s += ' lẻ';
            }
            else if (this.second === '1') {
                s += ' mười';
            }
            else if (this.second) {
                s += ` ${Utils_1.getNumberFromMap(this.second)} mươi`;
            }
            return s;
        }
        /**
         * Read the last number of three digits of the {@link Numbers}
         * @param s the input number in string
         * @return the result after adding first number
         */
        readFirstNumber(s) {
            if (this.first) {
                s = `${Utils_1.getNumberFromMap(this.first)} trăm`;
            }
            return s;
        }
    }
    exports.default = Numbers;
});
define("Billion", ["require", "exports", "Numbers"], function (require, exports, Numbers_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A group three numbers, a component in billion position of the input number
     */
    class Billion extends Numbers_1.default {
        read(firstNumber) {
            return `${super.read(firstNumber)} tỷ`.trim();
        }
    }
    exports.default = Billion;
});
define("Zerofill", ["require", "exports", "Numbers"], function (require, exports, Numbers_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A group three numbers, this component will deal with three zero numbers
     */
    class Zerofill extends Numbers_2.default {
        read(firstNumber) {
            if (this.first !== '0' || this.second !== '0' || this.last !== '0') {
                return `${super.read(firstNumber)} ${this.unitName}`;
            }
            else {
                return '';
            }
        }
    }
    exports.default = Zerofill;
});
define("Million", ["require", "exports", "Zerofill"], function (require, exports, Zerofill_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A group three numbers, a component in million position of the input number
     */
    class MillionNumber extends Zerofill_1.default {
        get unitName() {
            return 'triệu';
        }
    }
    exports.default = MillionNumber;
});
define("Thousand", ["require", "exports", "Zerofill"], function (require, exports, Zerofill_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A group three numbers, a component in thousand position of the input number
     */
    class Thousand extends Zerofill_2.default {
        get unitName() {
            return 'nghìn';
        }
    }
    exports.default = Thousand;
});
define("NumberReader", ["require", "exports", "Billion", "Million", "Numbers", "Thousand"], function (require, exports, Billion_1, Million_1, Numbers_3, Thousand_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A number reader in Vietnamese language helper
     */
    class NumberReader {
        /**
         * Read a number in Vietnamese language
         * @param number the number to read
         * @return a string of the number is read in vietnamese
         */
        static read(number) {
            let s = '';
            if (typeof number === 'number') {
                s = number.toString();
            }
            else {
                s = number;
            }
            const numberGroups = this.getGroupNumbers(s);
            const numbers = this.mapToNumbers(numberGroups);
            return this.readNumbers(numbers);
        }
        /**
         * Convert all {@link Numbers} objects to a string
         * @param numbers an array of {@link Numbers} objects
         * @return a {@link string} of the number is read in vietnamese
         */
        static readNumbers(numbers) {
            return numbers
                .reduce(function (result, group, index) {
                const beforeBillion = index + 1 < numbers.length && numbers[index + 1] instanceof Billion_1.default;
                return result.trim() + ' ' + group.read(index === 0, beforeBillion);
            }, '')
                .trim();
        }
        /**
         * Map all group numbers in {@link string} to {@link Numbers} objects
         * @param numberGroups group of numbers in string
         * @return an array of {@link Numbers}
         */
        static mapToNumbers(numberGroups) {
            const numbers = [];
            for (let i = numberGroups.length - 1, currentType = 0; i >= 0; i--) {
                numbers.unshift(this.getNumber(numberGroups[i], currentType++));
                currentType = currentType === 4 ? 1 : currentType;
            }
            return numbers;
        }
        /**
         * Generate a group of numbers from a string of number
         * @param s input string of number
         */
        static getGroupNumbers(s) {
            const numberGroups = [];
            const nGroup = Math.floor(s.length / 3);
            for (let i = 0; i < nGroup; i++) {
                numberGroups.unshift(s.substr(s.length - 3 - i * 3, 3));
            }
            if (s.length % 3 !== 0) {
                numberGroups.unshift(s.substr(0, s.length % 3));
            }
            return numberGroups;
        }
        /**
         * Map a number in string to a {@link Numbers} object
         * @param s input string to map
         * @param type type number of the {@link Numbers} object
         */
        static getNumber(s, type) {
            let number;
            switch (type) {
                case 0:
                    number = new Numbers_3.default(s);
                    break;
                case 1:
                    number = new Thousand_1.default(s);
                    break;
                case 2:
                    number = new Million_1.default(s);
                    break;
                case 3:
                    number = new Billion_1.default(s);
                    break;
            }
            return number;
        }
    }
    exports.default = NumberReader;
});
define("index", ["require", "exports", "NumberReader"], function (require, exports, NumberReader_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = NumberReader_1.default;
});
